The Model (final_model.ipynb):
The guiding principle of our model is that of ‘collaborative filtering’. Rather than trying to learn what would make a good playlist by inspecting various features of individual tracks we instead turn to the previous decisions of the user community, looking at existing playlists themselves and, for the moment, we disregard any intrinsic track features or track and playlist metadata. For us, a track’s identity just is what playlists it occurs in. Likewise, a playlist’s identity is nothing more than the tracks it contains.

We assume that tracks belong in playlists together if they are sufficiently similar. And we cash out our notion of ‘similarity’ entirely in terms of co-occurrence. That is, two tracks are considered similar if they frequently appear together in playlists. Likewise, two tracks which never co-occur are are assumed to be dissimilar and so should probably not be put in a playlist together. Again, the principle is that the user community knows what it’s doing when it makes playlists. Our model will simply and mimic that behavior.

Once we start thinking of a playlist as simply a list of tracks, it can be represented even more abstractly as a m-dimensional row vector of one-hot predictors where m is the total number of unique tracks in our dataset and each predictor corresponds to one track in our dataset. The value of a playlist vector P at index i will be 1 if P contains track i and 0 otherwise. We can then stack these playlist row vectors on top of one another to create an nXm matrix where n is the number of playlists and m the number of unique songs. Now, if we take the transpose of this matrix and multiple it with the original we get an mXm matrix, that is, our track co-occurrence matrix. This is the method tested in playlist_generator_model2.ipynb. We used an iterative approach to construct the co-occurrence matrix (COM) in playlist_generator_model1.ipynb.

Ultimately, for our final model we ended up using an approach similar to that in playlist_generator_model2.ipynb with one a major alteration. We do create a playlistXsong matrix as we did previously but here, instead of simple occurrence counts in each cell of the matrix we have tf-idf (term frequency-inverse document frequency) scores. The rationale here is that a song occurring in a very long playlist of 500 songs doesn’t seem to be as integral to the playlist’s ‘identity’ as would a song occurring in a playlist of only 5 songs. By similar reasoning, two songs occurring together in a 500 song playlist says significantly less about their similarity than their occurring together in a 5 song playlist. Weighting our counts using tf-idf helps us capture this fact in our matrix.

We used SKLearn’s TfidfVectorizer to create a the playlistXsong matrix. We simply represented each playlist as a single string, a document in which each word is a track id. Then the list of all our playlists can be passed to the vectorizer like any other text corpus. The vectorizer also makes use of SciPy’s sparse matrix representation, conserving a lot of memory, allowing for faster matrix operations (such as the one required to derive the singXsong matrix), and so permitting us to incorporate many more datafilee into the building of our model thane could in past iterations.

Playlist Generation:

To generate a playlist, our model can take a track name as input or ‘seed’ and a desired playlist length. The model then finds the row that corresponds to the seed track in the singXsong matrix, normalizes the row so it can be treated as a probability distribution, and samples tracks to be added to the playlist based on this distribution. More similar songs have a much higher chance of being picked. The model output is a list of songs: our new playlist!

The input to the model can also be a list of songs. Here the matrix rows corresponding to each song in the seed list are summed, and then treated as before. If there are not enough similar songs in a matrix row to complete a playlist, the picks found so far are summed in this fashion and used as the new seed. This prevents ‘dead ends’ from occurring when seeding with rare songs. Steps have also been taken to prevent songs from appearing more than once in a playlist.

[pics of generated playlists here]